console.log('Hello Bot!');

import {
  Bot,
  Context,
  GrammyError,
  HttpError,
  InlineKeyboard,
  InputFile,
  session,
  type SessionFlavor,
} from 'grammy';
import { hydrate, type HydrateFlavor } from '@grammyjs/hydrate';
import { I18n, type I18nFlavor } from '@grammyjs/i18n';
import { Menu } from '@grammyjs/menu';
import { chunk } from 'lodash';
import { initData, type Country, type Service } from './api/initData';
import _ from 'lodash';
import { setStatus } from './api/setStatus';
import { buyNumber } from './helpers/buyNumber';
import { waitingCode } from './helpers/waitingCode';
import { escapeMarkdownV2 } from './helpers/escapeMarkdownV2';

const init = await initData();

type SessionData = {
  __language_code?: string;
  countryActivePage: number;
  serviceActivePage: number;
  selected_country: Country;
  selected_service?: Service;
  from_buy_number: boolean;
  numberAbortController: {
    [id: string]: AbortController | null;
  };
};

type MyContext = HydrateFlavor<Context> & SessionFlavor<SessionData> & I18nFlavor;

const bot = new Bot<MyContext>(process.env.BOT_TOKEN!);

const i18n = new I18n<MyContext>({
  defaultLocale: 'ru',
  useSession: true,
  directory: 'locales',
});

bot.use(
  session({
    initial: (): SessionData => {
      return {
        countryActivePage: 0,
        serviceActivePage: 0,
        selected_country: init[0],
        from_buy_number: false,
        numberAbortController: {},
      };
    },
  })
);
bot.use(hydrate());
bot.use(i18n);

// * –ú–ï–ù–Æ –ü–û–ö–£–ü–ö–ò –ù–û–ú–ï–†–ê
const buyNumberMessage = '–ö—É–ø–∏—Ç—å –Ω–æ–º–µ—Ä';
const buyNumberMenu = new Menu<MyContext>('buy-number-menu');
buyNumberMenu.dynamic(async (ctx, range) => {
  const country = ctx.session.selected_country;
  const service = ctx.session.selected_service;
  console.log(service?.name);

  if (service) {
    range.text('‚úâ –ü–æ–ª—É—á–∏—Ç—å –°–ú–°', async (ctx) => {
      const abortControllerId = _.uniqueId();
      const message = await ctx.reply('‚åõ –ò–¥–µ—Ç –ø–æ–∏—Å–∫ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –Ω–æ–º–µ—Ä–∞', {
        reply_markup: new InlineKeyboard().text(
          'üö´ –û—Ç–º–µ–Ω–∞',
          `cancelNumberFetch-${abortControllerId}`
        ),
      });

      const controller = new AbortController();
      ctx.session.numberAbortController[abortControllerId] = controller;

      buyNumber(country.id, service.id, controller.signal).then(async (data) => {
        if (data) {
          const { id, phone } = data;
          const locale = await ctx.i18n.getLocale();
          const countryName = `${country.emoji} ${
            locale === 'ru' ? country.ru_name : country.en_name
          }`;

          await message.editText(
            ctx.t('activation-success-message', {
              id: id.toString(),
              country: escapeMarkdownV2(countryName),
              service: escapeMarkdownV2(service.name),
              number: phone.toString(),
            }),
            {
              parse_mode: 'MarkdownV2',
              reply_markup: new InlineKeyboard().text(
                'üö´ –í–µ—Ä–Ω—É—Ç—å –¥–µ–Ω—å–≥–∏',
                `cancel-purchase:${id}:${phone}:${country.id}:${service.id}`
              ),
            }
          );

          async function waitForCodeAndReply(
            id: number,
            phone: number,
            ctx: MyContext,
            msg: typeof message,
            count: number
          ) {
            const code = await waitingCode(id);
            if (code) {
              if (count === 1) await msg.editReplyMarkup();
              await ctx.reply(ctx.t('activation-code', { code, count }), {
                parse_mode: 'MarkdownV2',
                reply_parameters: {
                  quote: '‚òé *–ù–æ–º–µ—Ä:*' + ' ‚Å®' + phone,
                  quote_parse_mode: 'MarkdownV2',
                  message_id: msg.message_id,
                },
              });

              const status = await setStatus({ id, status: 3 });
              if (status === 'ACCESS_RETRY_GET') {
                waitForCodeAndReply(id, phone, ctx, message, count + 1);
              }
            }
          }

          waitForCodeAndReply(id, phone, ctx, message, 1);
        } else {
          ctx.session.numberAbortController[abortControllerId] = null;
          await message.editText('üö´ –û—Ç–º–µ–Ω–∞ –ø–æ–∫—É–ø–∫–∏ –Ω–æ–º–µ—Ä–∞');
        }
      });
    });
  }

  range.row();
  range.text('‚≠êÔ∏è –î–æ–±–∞–≤–∏—Ç—å –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ', async (ctx) => {
    await ctx.reply('‚öí –í —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ');
  });
  range.text('üåé –ò–∑–º–µ–Ω–∏—Ç—å —Å—Ç—Ä–∞–Ω—É', async (ctx) => {
    ctx.session.from_buy_number = true;
    await openCountryList(ctx);
  });

  range.row();
  range.text('‚¨Ö –ù–∞–∑–∞–¥', async (ctx) => await openServiceList(ctx));
  range.text('üè† –ù–∞ –≥–ª–∞–≤–Ω—É—é', async (ctx) => await backToMainMenu(ctx));
});

// * –ú–ï–ù–Æ –í–´–ë–û–†–ê –°–ï–†–í–ò–°–ê
const changeServiceMenu = new Menu<MyContext>('change-service-menu');
changeServiceMenu.dynamic(async (ctx, range) => {
  const services = Object.values(ctx.session.selected_country.services);
  if (services.length) {
    const servicesPages = chunk(services, 18);
    const session = await ctx.session;
    servicesPages[session.serviceActivePage].forEach((s, i) => {
      range.text(s.name, async (ctx) => {
        ctx.session.selected_service = s;
        await openServicePage(ctx);
      });

      if (i % 3 === 2) range.row();
    });

    range.row();
    if (session.serviceActivePage > 0) {
      range.submenu('‚¨Ö –ù–∞–∑–∞–¥', 'change-service-menu', () => {
        session.serviceActivePage--;
      });
    } else range.text('„Ö§');

    if (session.serviceActivePage > 0) {
      range.submenu(
        `${session.serviceActivePage + 1}/${servicesPages.length}`,
        'change-service-menu',
        () => (session.serviceActivePage = 0)
      );
    } else range.text(`${session.serviceActivePage + 1}/${servicesPages.length}`);

    if (session.serviceActivePage < servicesPages.length - 1) {
      range.submenu('–î–∞–ª–µ–µ ‚û°', 'change-service-menu', () => {
        session.serviceActivePage++;
      });
    } else range.text('„Ö§');
  }

  range.row().text('üè† –ù–∞ –≥–ª–∞–≤–Ω—É—é', async (ctx) => await backToMainMenu(ctx));
});
changeServiceMenu.register(buyNumberMenu);

// * –ú–ï–ù–Æ –ò–ó–ú–ï–ù–ï–ù–ò–Ø –°–¢–†–ê–ù–´
const changeCountryMenu = new Menu<MyContext>('change-country-menu');
changeCountryMenu.dynamic(async (ctx, range) => {
  let countriesPages = chunk(Object.values(init), 18);

  if (ctx.session.from_buy_number && ctx.session.selected_service) {
    countriesPages = chunk(
      _.filter(init, (item) => _.has(item.services, ctx.session.selected_service!.id)),
      18
    );
  }

  const session = await ctx.session;
  const locale = await ctx.i18n.getLocale();
  countriesPages[session.countryActivePage].forEach((c, i) => {
    const text = `${c.emoji} ${locale === 'ru' ? c.ru_name : c.en_name}`;

    if (ctx.session.from_buy_number) {
      range.text(text, async (ctx) => {
        ctx.session.selected_country = c;
        await openServicePage(ctx);
      });
    } else {
      range.text(text, async (ctx) => {
        ctx.session.selected_country = c;
        await backToMainMenu(ctx);
      });
    }

    if (i % 3 === 2) range.row();
  });

  range.row();
  if (countriesPages.length > 1) {
    if (session.countryActivePage > 0) {
      range.submenu('‚¨Ö –ù–∞–∑–∞–¥', 'change-country-menu', () => {
        session.countryActivePage--;
      });
    } else range.text('„Ö§');

    if (session.countryActivePage > 0) {
      range.submenu(
        `${session.countryActivePage + 1}/${countriesPages.length}`,
        'change-country-menu',
        () => (session.countryActivePage = 0)
      );
    } else range.text(`${session.countryActivePage + 1}/${countriesPages.length}`);

    if (session.countryActivePage < countriesPages.length - 1) {
      range.submenu('–î–∞–ª–µ–µ ‚û°', 'change-country-menu', () => {
        session.countryActivePage++;
      });
    } else range.text('„Ö§');
  }

  range.row();
  if (ctx.session.from_buy_number) {
    range.submenu('‚¨Ö –ù–∞–∑–∞–¥', 'buy-number-menu', (ctx) => {
      ctx.session.from_buy_number = false;
    });
  } else {
    range.text('üè† –ù–∞ –≥–ª–∞–≤–Ω—É—é', async (ctx) => await backToMainMenu(ctx));
  }
});

// * –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ
const mainMenu = new Menu<MyContext>('main-menu')
  .text('‚úâ –ö—É–ø–∏—Ç—å –Ω–æ–º–µ—Ä', async (ctx) => await openServiceList(ctx))
  .text('‚≠êÔ∏è –ò–∑–±—Ä–∞–Ω–Ω–æ–µ', async (ctx) => {
    await ctx.reply('‚öí –í —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ');
  })
  .row()
  .text('üåé –ò–∑–º–µ–Ω–∏—Ç—å —Å—Ç—Ä–∞–Ω—É', async (ctx) => await openCountryList(ctx))
  .text('üí∞ –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å', async (ctx) => {
    await ctx.reply('‚öí –í —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ');
  });

mainMenu.register(changeServiceMenu, 'main-menu');
mainMenu.register(changeCountryMenu);

// * –ö–ù–û–ü–ö–ê "üè† –ú–ï–ù–Æ"
const menuButton = new Menu<MyContext>('menu-button').text(
  'üè† –ú–µ–Ω—é',
  async (ctx) => await backToMainMenu(ctx)
);

bot.use(mainMenu);
bot.use(menuButton);

bot.callbackQuery(/cancelNumberFetch-(.+)/, async (ctx) => {
  const id = ctx.callbackQuery.data.split('-')[1];
  if (ctx.session.numberAbortController[id]) {
    ctx.session.numberAbortController[id].abort();
  }
});

bot.callbackQuery(/cancel-purchase:\d+:\d+:\d+:.+/, async (ctx) => {
  await ctx.answerCallbackQuery();
  const [_, id, phone, countryId, serviceId] = ctx.callbackQuery.data.split(':');
  const status = await setStatus({ id: Number(id), status: 8 });

  if (status === 'ACCESS_CANCEL') {
    const locale = await ctx.i18n.getLocale();
    const service = init[Number(countryId)].services[serviceId];
    const country = init[Number(countryId)];
    const countryName = `${country.emoji} ${
      locale === 'ru' ? country.ru_name : country.en_name
    }`;

    await ctx.editMessageText(
      ctx.t('cancellation-message', {
        id: id.toString(),
        country: escapeMarkdownV2(countryName),
        service: escapeMarkdownV2(service.name),
        number: phone.toString(),
      }),
      {
        parse_mode: 'MarkdownV2',
        reply_markup: menuButton,
      }
    );
  } else {
    console.log(status);
  }
});

// * –§–£–ù–ö–¶–ò–ò –û–¢–ö–†–´–¢–ò–Ø –ú–ï–ù–Æ
async function openCountryList(ctx: MyContext) {
  ctx.session.countryActivePage = 0;
  await ctx.editMessageCaption({
    caption: ctx.t('change-country'),
    reply_markup: changeCountryMenu,
  });
}

async function openServiceList(ctx: MyContext) {
  ctx.session.from_buy_number = false;
  await ctx.editMessageCaption({
    caption: ctx.t('change-service'),
    reply_markup: changeServiceMenu,
  });
}

async function openServicePage(ctx: MyContext) {
  ctx.session.from_buy_number = true;
  await ctx.editMessageCaption({
    caption: buyNumberMessage,
    reply_markup: buyNumberMenu,
  });
}

async function backToMainMenu(ctx: MyContext) {
  ctx.session.from_buy_number = false;
  ctx.session.serviceActivePage = 0;
  ctx.session.countryActivePage = 0;

  const locale = await ctx.i18n.getLocale();
  const country = ctx.session.selected_country;
  const countryName = `${country.emoji} ${
    locale === 'ru' ? country.ru_name : country.en_name
  }`;

  try {
    await ctx.editMessageCaption({
      caption: ctx.t('main-menu', {
        balance: '‚öí –í —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ',
        country: escapeMarkdownV2(countryName),
      }),
      parse_mode: 'MarkdownV2',
      reply_markup: mainMenu,
    });
  } catch (error) {
    await ctx.replyWithPhoto(new InputFile('./assets/banner2.png'), {
      caption: ctx.t('main-menu', {
        balance: '‚öí –í —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ',
        country: escapeMarkdownV2(countryName),
      }),
      parse_mode: 'MarkdownV2',
      reply_markup: mainMenu,
    });
  }
}

// * –ë–õ–û–ö –ó–ê–ü–£–°–ö–ê –ë–û–¢–ê
bot.command('start', async (ctx) => await backToMainMenu(ctx));
bot.start();
bot.catch((err) => {
  const ctx = err.ctx;
  console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è ${ctx.update.update_id}:`);
  const e = err.error;
  if (e instanceof GrammyError) {
    console.error('–û—à–∏–±–∫–∞ –≤ –∑–∞–ø—Ä–æ—Å–µ:', e.description);
  } else if (e instanceof HttpError) {
    console.error('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≤—è–∑–∞—Ç—å—Å—è —Å Telegram:', e);
  } else {
    console.error('–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞:', e);
  }
});
